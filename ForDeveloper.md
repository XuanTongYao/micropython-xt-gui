# 开发者请看

- [开发者请看](#开发者请看)
  - [1. 项目文件结构](#1-项目文件结构)
  - [2. GUI核心架构](#2-gui核心架构)
  - [3. 控件绘制详细说明](#3-控件绘制详细说明)
  - [4. 按键响应详细说明](#4-按键响应详细说明)
  - [5. 事件触发，函数调用约定](#5-事件触发函数调用约定)
  - [5. 定义详细说明](#5-定义详细说明)
    - [绘制层栈](#绘制层栈)
    - [已进入控件栈](#已进入控件栈)
    - [帧缓冲切片](#帧缓冲切片)
    - [容器绘制区域](#容器绘制区域)
    - [控件分类](#控件分类)

## 1. 项目文件结构

核心模块：

- [资源 ./resource/](./resource/)
- [GUI ./gui/](./gui/)
- [显示驱动 ./driver/](./driver/)
- [附件 ./add_ons/](./add_ons/)
- [Demos ./demos/](./demos/)

**资源**：字体，图片，文本等资源全部放在该文件夹内。

**显示驱动**：有关显示驱动的.py文件全部放在该文件夹内。

**附件**：不属于GUI组件但某些Demo需要的模块放在该文件夹内。

**Demos**：所有可运行的有关Demo的.py文件全部放在该文件夹内。

**GUI**：GUI核心组件以及实用工具放在该文件夹内。

## 2. GUI核心架构

- [XT_GUI](./gui/xt_gui.py)核心主程序
- - 异步主循环
- - 维护绘制层栈
- - 维护已进入控件栈
- - 传递按键响应参数
- - 触发绘制并刷新GDDRAM
- - 绘制文字

- [KeyHandler](./gui/key_handler.py)处理物理按键输入
- - 物理按键消抖
- - 按键异步扫描循环
- - 按键事件(按下，释放，长按)及回调支持

- [BMFont](./gui/ufont.py)点阵字体加载器
- - 加载不完整字体集的字体文件
- - 获取字体点阵数据
- - 缩放字体点阵数据 (性能问题)

- [XWidget](./gui/widgets/base.py)核心控件

- [DisplayAPI](./gui/utils/core.py)屏幕驱动通用接口
- - GUI核心与显示驱动的中间件
- - 双缓冲刷新
- - 负责生成帧缓冲切片

- [Utils](./gui/utils/core.py)通用工具
- - GUI单例管理
- - 常用颜色定义
- - 按键键值定义、按键响应返回值定义
- - 颜色转换
- - 图像解码
- - 平面图形 (TODO)

## 3. 控件绘制详细说明

本项目的核心组件均使用双缓冲绘图，为了提高性能还采用了延迟绘图的方式。

所谓延迟绘图就是在每个控件中添加一个标志，用来指明是否需要重绘，如果不需要重绘则会直接跳过。同时在每个容器控件中添加一个标志，用来指明是否需要擦除容器绘制区域，防止绘制时出现残影。

绘制只能由GUI实例来触发，对于控件使用递归调用的方式绘制；

绘制过程中不会修改需要重绘的标志，这些标志只会在事件触发过程修改。

下面这段伪代码表示触发绘制并刷新GDDRAM的流程：
**最新机制请参考代码，文档可能有滞后。**

```python
while True:
    绘制层 = 绘制层栈.栈顶()
    绘制层.传递绘制()
    刷新帧()


def 传递绘制:
    if 需要重绘:
        绘制()
    if 自身绘制区域无效:
        return

    已擦除标志 = False
    for 子控件 in 子控件列表:
        if 子控件超出容器绘制区域:
            continue
        if 子控件 is 容器控件:
            子控件.传递绘制()
        elif 子控件.需要重绘:
            子控件.绘制()
        
```

**重绘标志在以下条件下必须被设置：**

- 控件的父控件被更改时；
- 控件位置、大小、焦点状态等一切能够影响绘制结果的参数被更改时；
- 收到**擦除容器绘制区域事件**时；
- 收到**重建容器绘制区域事件**时；

**擦除容器绘制区域在以下条件下必须被执行：**

- 收到**变换事件**时；

## 4. 按键响应详细说明

[XCtrl](./gui/widgets/base.py)类都拥有一个`_key_input`属性，用于接收[按键键值](./gui/utils/key.py)输入，并返回一个响应结果。
GUI实例通过调用`_key_input`将按键响应的键值传递给**已进入控件栈**栈顶元素或**基础绘制层**，并获得一个响应结果返回值。

响应结果返回值通常有三种：

1. **ESC**:表示将退出该控件。通常返回给GUI实例。
2. **ENTER**:表示将进入该控件。通常返回给父控件。
3. 一个**可控制控件**对象:表示要进入该控件。通常返回给GUI实例。

父控件需要对**ENTER**返回值进行处理，通常是将当前焦点控件返回给GUI实例。

焦点控制:**容器控件**(例如XFrameLayout)通常需要进行焦点控制，除了用于切换焦点的键值，其余键值需要被传递到当前焦点控件，位于焦点的控件会被突出显示(取决于其绘制函数)。显然，仅有**可控制控件**拥有焦点状态。

## 5. 事件触发，函数调用约定

在控件对象的正常生命周期中，只要用户没有手动调用私有或弱私有方法，它们的事件触发和相关函数调用必须遵循以下约定，同时GUI保证这些约定有效。

---

可以查看[源代码](./gui/widgets/base.py)中`_event_receiver`、`_transfer_event_trigger`、`_rebuild_draw_area_event_handler`相关内容。

事件触发：事件被触发后执行相关操作，并将事件传递到相关控件。

控件拥有事件触发器、事件接收器、事件处理器。

控件内建有以下事件，在特定的条件下被触发，用于实现某些特定功能：

1. 变换事件：控件的位置、大小被更改时；只向最近的父控件分发。
2. 重建容器绘制区域事件：控件重建容器绘制区域时；只向子控件分发。
3. 擦除容器绘制区域事件：控件擦除容器绘制区域时；只向子控件分发。

---

函数调用约定：

1. 绘制只会由GUI或父控件递归调用；当其被调用时，始终认为其父控件有效，不需要对父控件进行类型检查。
2. 重建容器绘制区域只会在父控件有效时调用；当其被调用时，始终认为其父控件有效，不需要对父控件进行类型检查。

## 5. 定义详细说明

### 绘制层栈

GUI实例允许存在多个绘制层，常用于实现切换页面的效果(不支持半透明合成和叠加显示)。多个绘制层以栈的形式进行维护，GUI只绘制栈顶的绘制层。**绘制层栈**中的元素全部为容器控件。栈底元素是是每个GUI实例固定保留的绘制层(**基础绘制层**)，不允许退出(弹栈)，默认为XFrameLayout类型:不带边框的平面布局容器。

创建绘制层/移除绘制层 对应着 压栈/弹栈操作。

### 已进入控件栈

GUI实例维护一个**已进入控件栈**，用于将按键输入的键值传递给栈顶元素。**已进入控件栈**的元素全部为**可控制控件**。如果**已进入控件栈**为空，则键值传递给**基础绘制层**。

进入控件/退出控件 对应着 压栈/弹栈操作。

### 帧缓冲切片

GUI依赖于双缓冲绘图刷新，DisplayAPI类保留一个全屏幕的帧缓冲区，以Bitmap的格式保存在内存中。借助[FrameBuffer](https://docs.micropython.org/en/latest/library/framebuf.html)可以从全屏幕帧缓冲区中截取一个允许读写的矩形区域，称为**帧缓冲切片**。**帧缓冲切片**不保存Bitmap格式的像素信息，因此不会占用额外内存。对超出**帧缓冲切片**的区域进行绘制操作将自动忽略，可以实现限定绘制区域的效果。

由于使用了[framebuf](https://docs.micropython.org/en/latest/library/framebuf.html)库，`DisplayAPI`继承自`framebuf.FrameBuffer`，因此`DisplayAPI`对象可以调用`framebuf.FrameBuffer`中的方法，同时内部带有一个帧缓冲区`self.buffer`。

`DisplayAPI`类有一个特殊的方法`framebuf_slice( x, y, w, h)`，用来生成一个帧缓冲区，该帧缓冲区可以指定偏移量，对应显示器全屏帧缓冲区的部分区域。主要用于实现掩码效果，利用`framebuf.FrameBuffer`的特性，超出缓冲区区域的部分会自动跳过绘制，同时不会影响性能，可以很好的将图形绘制到指定区域内(例如：子控件超出父容器区域的画面自动忽略绘制)。因为非`framebuf.GS8`和`framebuf.RGB565`像素格式的帧缓冲区使用单个字节保存了多个像素的数据，为了精确定位到每一个像素，使用了`FrameBufferOffset`类保存了绘制时x坐标应该进行的偏移量。

帧缓冲切片通常由DisplayAPI类生成。

### 容器绘制区域

容器的子控件当然只允许在容器的区域内绘制。每个容器都拥有自己的**容器绘制区域**，其本质是一个**帧缓冲切片**。

**重建容器绘制区域在以下条件下必须被触发：**

- 控件的父控件被更改时；
- 控件的位置、大小被更改时；
- 收到**重建容器绘制区域事件**时；

### 控件分类

有三种控件：单一控件、可控制控件和容器控件

单一控件：继承自[XWidget](./gui/widgets/base.py)，且不属于可控制控件和容器控件的控件。仅做显示功能。

可控制控件：继承自[XCtrl](./gui/widgets/base.py)的控件。允许响应按键输入。

容器控件：继承自[XLayout](./gui/widgets/base.py)的控件。允许响应按键输入；是一种特殊的可控制控件；允许包含子控件；拥有自身的布局方法。
